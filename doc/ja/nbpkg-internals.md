# nbpkg-build インターナル: basepkg 配布システムの裏側

## 問題の根幹

これは、はっきりしていて、ユーザランドの構成法に由来します。
数千個部品を組み上げるのか？
一つのソースコードから作成しているのか？
これは一種のトップダウン対ボトムアップという構図です。

Linuxのインストールは数千個のパッケージを入れて構成しています。
つまりユーザランドは etc-password-1.0 bin-ls-2.0 などの集合体で、
このインストール情報がパッケージとして管理できています。

一方 BSD Unixでは、まるっとNetBSD 8.0の配布物などとなってしまうので、
ユーザランドの部品の区別がありません。
あえていえば
etc-password-8.0 bin-ls-8.0 などといった表記法になるのかもしれませんが、
現在の /bin/ls が NetBSD 8.0 release なのか、
それとも netbsd-8 からビルドした版なのか？を知る汎用的な方法がありません。

NetBSD 8.0 から新登場した sys_info (/usr/bin/sys_info by agc@)
が一部教えてくれますが、/etc/passwd や ls のバージョンなどは分かりません。


## 暫定案

### 基準点、バージョン番号、差分の把握

* 公式メジャーリリースを基点とします。つまり基準点を、こちらで決めます。
    * basepkg パッケージのバージョンは「8.0.日付」とします。
       この日付は daily build が実行された日です。
       よって、
       base-sys-root-8.0.20181101.tgz などいうパッケージ名になります。
* 基準との差分を、どのようにして知るのか？というと ident 情報です。


### 維持管理する情報

生成システムが追跡するべき情報は次の二つです。
*   ident 情報: メジャーリリースおよび daily build の ident 履歴
* basepkg 情報: リリースした basepkg の履歴


### サーバ側での動作(配布パッケージの作成時)

作成するマスタープロセス nbpkg-build 側で、basepkg に指示を与えます。

1. ident情報に基づき daily build にアップデートがあったかを検査
    1. 変化がない場合、終了

1. 設定の準備
    1. daily build のident情報一覧を作成、保存
        1. 維持管理している情報その１：identの一覧
	   メジャーリリースおよび daily build の履歴を維持管理。
	   daily build の変化がある際に更新。
	   ファイルに保存されている情報は生成済み分のident最新情報。
	   例: /var/nbpkg-build/db/ident/netbsd-8/i386
    1. 変化した basepkg の一覧を作成
    1. basepkg の作成履歴も更新(依存関係)
        1. 維持管理している情報その２：リリースしたbasepkg一覧
	   identにもとづいて何らかの変化があったパッケージのみを作成。
	   ジャーナル型で複数回リリースがあったならそれらの全履歴を含む。
	   ```
	   base-sys-util  8.0.20181001
	   base-sys-shlib 8.0.20181001
	      ...
	   base-sys-util  8.0.20181020
	      ... 
	   ```
	   例: /var/nbpkg-build/db/basepkg/netbsd-8/i386
    1. basepkg に、これら二つの情報から生成した設定を渡し、
       必要なパッケージのみを作成。
       
   
1. basepkg 側にも手を入れて、
   nbpkg-build の指示で動く場合だけは、
   依存関係(@pkgdep)に手を入れながら、パッケージを作成する特別な挙動をします。
   * 作成するものはident情報から判定し、
     @pkgdep は basepkg の作成履歴から情報を作る。
     (上の例を使って説明すると) 20181130 に更新した comp-xxx-yyy が
     base-sys-shlib と base-sysutil に依存していた場合、
     パッケージには次のような依存情報が書き込まれます。
     ```
     @pkgdep base-sys-shlib>=8.0.20181001
     @pkgdep  base-sys-util>=8.0.20181020
     ```
	   

### クライアント側の動作

pkgsrc のツール群を使うことを前提にしています。
リファレンス実装の nbpkg.sh は pkgin や pkg_add の単なる wrapper です。  

問題は、基準点がわからないことです。
OS 上で、インストール情報が管理されていないので、
いま使っているシステムが
8.0 リリースなのか 8.0 stable の 20180801 版なのかも確実には分かりません。

依存性解決の案が二つあります。

1. /var/db/pkg に major official release のパッケージ情報を作成。
   パッケージにも、その依存関係情報が入っている。
   8.0リリース(2018/07/17にリリース)なら、
   8.0リリースから変化がないパッケージについても、
   ```
   @pkgdep package>=8.0.20180717
   ```
   などと書いてある。

1. パッケージ側の依存関係を操作して、
   メジャーリリース以降の依存関係だけを書いておく。
   このプランでは
   ```
   @pkgdep package>=8.0.20180717
   ```
   行は削除される。

パッケージ内の依存関係例は、
前者の場合：
/var/db/pkgには、すでにメジャーリリースに相当する
千個あまりの cate-gory-pkg-8.0.20180717 情報が登録することになります
(実体は、すでにインストール済みなので、/var/db/pkgに情報を書き込むだけです)。
各パッケージには、次のような依存関係が書いてあります。
```
@pkgdep base-sys-root>=8.0.20180717
@pkgdep base-sys-util>=8.0.20181111
```

後者の案では、
通常どおり /var/db/pkg には pkgsrc の分だけがあります。
各パッケージの依存関係に 8.0.20180717 分は挿入しません。
例：
```
@pkgdep base-sys-util>=8.0.20181111
```

なぜなら、8.0リリースに相当する
```
@pkgdep base-sys-root>=8.0.20180717
```
行の情報が存在すると、
/var/db/pkg
を見に行き、存在しないことを発見します。
その結果、アップデートする必要のない
base-sys-root
をインストールしようとしてしまいます。



## 履歴: プランAとプランB

方針を受けて、プランBが現在の実装になっています。

最初に作成した プランA (JNUG 2018 NetBSD BoF で紹介した実装)は、
とにかく daily build から basepkg パッケージを作り、
クライアント側の設定でインストールするべきものを選択するという方式です。
設定は、セキュリティアドバイザリに従って誰かが作成するということになるので、
どうしても人の手が必要になってしまう運用に難のある方式です。

プランB は、ソースコードに埋められている ident 情報を見て、
変化のあった basepkg だけを作成するという案です。
海外ドラマでプランB というと、たいてい「行きあたりばったり」のことですが、
ここでは、ちゃんとした第２案です(w)。


## 謝辞

プランBは、
JNUG 2018 NetBSD BoFでの Onodera 案(ryoon@)にもとづいています。
議論に参加してくれた皆さん、ありがとうございます。
